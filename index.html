from flask import Flask, Response, jsonify, request
from flask_cors import CORS
import cv2
import threading
import time
import json
import os
import sys
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('server.log')
    ]
)

logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

class CloudCameraStream:
    def __init__(self):
        self.camera = None
        self.latest_frame = None
        self.lock = threading.Lock()
        self.is_running = False
        self.stats = {
            'frames_captured': 0,
            'clients_connected': 0,
            'start_time': time.time(),
            'stream_quality': 'HD',
            'server_uptime': 0,
            'active_clients': 0
        }
        self.port = int(os.environ.get('PORT', 5000))
        self.host = '0.0.0.0'
        self.public_url = os.environ.get('PUBLIC_URL', f'http://localhost:{self.port}')
        
    def initialize_camera(self):
        """Initialize the camera with multiple fallback options"""
        camera_indexes = [0, 1, 2, -1]  # Try different camera indexes
        
        for index in camera_indexes:
            try:
                logger.info(f"Attempting to initialize camera index {index}")
                self.camera = cv2.VideoCapture(index)
                
                if self.camera.isOpened():
                    # Set camera properties
                    self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
                    self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
                    self.camera.set(cv2.CAP_PROP_FPS, 25)
                    self.camera.set(cv2.CAP_PROP_BUFFERSIZE, 1)  # Reduce buffer size
                    
                    # Test camera
                    success, frame = self.camera.read()
                    if success:
                        logger.info(f"‚úÖ Camera initialized successfully on index {index}")
                        return True
                    else:
                        self.camera.release()
                        self.camera = None
                else:
                    logger.warning(f"Camera index {index} not available")
                    
            except Exception as e:
                logger.error(f"Error initializing camera index {index}: {e}")
                if self.camera:
                    self.camera.release()
                    self.camera = None
        
        logger.error("‚ùå No camera available - using test pattern mode")
        return False
    
    def generate_test_pattern(self, width=640, height=480):
        """Generate an informative test pattern"""
        import numpy as np
        frame = np.zeros((height, width, 3), dtype=np.uint8)
        
        # Fill with gradient background
        for y in range(height):
            color = int(255 * (y / height))
            frame[y, :] = [color // 2, color // 3, color]
        
        # Add header
        cv2.putText(frame, "üåê CLOUD WEBCAM STREAM", (50, 50), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
        
        # Add server information
        cv2.putText(frame, f"Server Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", 
                   (50, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        cv2.putText(frame, f"Frames Captured: {self.stats['frames_captured']}", 
                   (50, 120), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        cv2.putText(frame, f"Active Clients: {self.stats['active_clients']}", 
                   (50, 150), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        # Add connection info
        cv2.putText(frame, "LOCAL: http://localhost:5000", 
                   (50, 190), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
        
        if 'ngrok' in self.public_url or 'localhost' not in self.public_url:
            cv2.putText(frame, f"CLOUD: {self.public_url}", 
                       (50, 220), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
        
        # Add animated elements
        t = time.time()
        
        # Moving circle
        circle_x = int(width/2 + width/4 * np.sin(t))
        circle_y = int(height/2 + height/4 * np.cos(t * 0.7))
        cv2.circle(frame, (circle_x, circle_y), 40, (0, 0, 255), -1)
        
        # Rotating line
        line_length = 100
        line_x = int(width/2 + line_length * np.sin(t))
        line_y = int(height/2 + line_length * np.cos(t))
        cv2.line(frame, (width//2, height//2), (line_x, line_y), (255, 255, 0), 3)
        
        # Grid pattern
        for i in range(0, width, 40):
            cv2.line(frame, (i, 250), (i, height), (50, 50, 50), 1)
        for i in range(250, height, 40):
            cv2.line(frame, (0, i), (width, i), (50, 50, 50), 1)
        
        # Status message
        cv2.putText(frame, "TEST PATTERN - No Camera Detected", 
                   (width//2 - 180, height - 30), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
        
        return frame
    
    def start_streaming(self):
        """Start the main streaming loop"""
        camera_available = self.initialize_camera()
        self.is_running = True
        
        logger.info("üé• Starting video stream...")
        frame_count = 0
        last_log_time = time.time()
        
        while self.is_running:
            try:
                # Capture frame from camera or generate test pattern
                if camera_available and self.camera is not None:
                    success, frame = self.camera.read()
                    if not success:
                        logger.warning("Failed to read from camera, using test pattern")
                        frame = self.generate_test_pattern()
                        # Try to reinitialize camera
                        camera_available = self.initialize_camera()
                else:
                    frame = self.generate_test_pattern()
                
                # Add timestamp and overlay
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                cv2.putText(frame, f"LIVE | {timestamp}", (10, 25), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
                
                cv2.putText(frame, f"Clients: {self.stats['active_clients']} | Frames: {self.stats['frames_captured']}", 
                           (10, 55), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
                
                # Encode frame as JPEG
                encode_params = [cv2.IMWRITE_JPEG_QUALITY, 85]
                ret, buffer = cv2.imencode('.jpg', frame, encode_params)
                
                if ret:
                    frame_bytes = buffer.tobytes()
                    with self.lock:
                        self.latest_frame = frame_bytes
                        self.stats['frames_captured'] += 1
                        frame_count += 1
                
                # Log performance every 30 seconds
                current_time = time.time()
                if current_time - last_log_time > 30:
                    fps = frame_count / (current_time - last_log_time)
                    logger.info(f"Stream performance: {fps:.1f} FPS, {self.stats['active_clients']} clients")
                    frame_count = 0
                    last_log_time = current_time
                
                # Control frame rate
                time.sleep(0.04)  # ~25 FPS
                
            except Exception as e:
                logger.error(f"Error in streaming loop: {e}")
                time.sleep(1)  # Wait before retrying
    
    def get_latest_frame(self):
        """Get the latest frame in a thread-safe manner"""
        with self.lock:
            return self.latest_frame
    
    def get_stats(self):
        """Get current streaming statistics"""
        with self.lock:
            stats = self.stats.copy()
            stats['server_uptime'] = time.time() - stats['start_time']
            stats['fps'] = stats['frames_captured'] / stats['server_uptime'] if stats['server_uptime'] > 0 else 0
            stats['public_url'] = self.public_url
            stats['server_time'] = datetime.now().isoformat()
            stats['status'] = 'running'
            return stats
    
    def client_connected(self):
        """Track new client connection"""
        with self.lock:
            self.stats['clients_connected'] += 1
            self.stats['active_clients'] += 1
            logger.info(f"Client connected. Total clients: {self.stats['active_clients']}")
    
    def client_disconnected(self):
        """Track client disconnection"""
        with self.lock:
            self.stats['active_clients'] = max(0, self.stats['active_clients'] - 1)
            logger.info(f"Client disconnected. Active clients: {self.stats['active_clients']}")
    
    def stop(self):
        """Cleanup and stop streaming"""
        self.is_running = False
        if self.camera is not None:
            self.camera.release()
        cv2.destroyAllWindows()
        logger.info("üõë Stream stopped gracefully")

# Global stream manager instance
stream_manager = CloudCameraStream()

@app.route('/')
def index():
    """Main API information endpoint"""
    info = {
        "service": "Cloud Webcam Streaming API",
        "version": "2.0.0",
        "status": "running",
        "endpoints": {
            "/": "This information",
            "/video": "MJPEG video stream",
            "/snapshot": "Single JPEG snapshot", 
            "/stats": "Stream statistics",
            "/health": "Health check",
            "/info": "Server information"
        },
        "documentation": "See /info for connection details",
        "timestamp": datetime.now().isoformat()
    }
    return jsonify(info)

@app.route('/video')
def video_feed():
    """MJPEG video stream endpoint with proper CORS headers"""
    stream_manager.client_connected()
    
    def generate():
        try:
            while True:
                frame = stream_manager.get_latest_frame()
                if frame is not None:
                    yield (b'--frame\r\n'
                           b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
                else:
                    # Send a small delay when no frame is available
                    time.sleep(0.1)
        except GeneratorExit:
            logger.info("Client disconnected from video stream")
            stream_manager.client_disconnected()
        except Exception as e:
            logger.error(f"Error in video stream: {e}")
            stream_manager.client_disconnected()
    
    response = Response(
        generate(),
        mimetype='multipart/x-mixed-replace; boundary=frame',
        headers={
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0',
            'Access-Control-Allow-Origin': '*'
        }
    )
    return response

@app.route('/snapshot')
def snapshot():
    """Single frame snapshot endpoint"""
    frame = stream_manager.get_latest_frame()
    if frame is not None:
        return Response(
            frame, 
            mimetype='image/jpeg',
            headers={
                'Cache-Control': 'no-cache',
                'Access-Control-Allow-Origin': '*'
            }
        )
    else:
        return jsonify({"error": "No frame available"}), 404

@app.route('/stats')
def stats():
    """Stream statistics endpoint"""
    stats_data = stream_manager.get_stats()
    return jsonify(stats_data)

@app.route('/health')
def health_check():
    """Health check endpoint for monitoring"""
    return jsonify({
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "uptime": stream_manager.get_stats()['server_uptime']
    })

@app.route('/info')
def server_info():
    """Server information and connection details"""
    stats = stream_manager.get_stats()
    
    info = {
        "server": {
            "status": "running",
            "version": "2.0.0",
            "start_time": datetime.fromtimestamp(stats['start_time']).isoformat(),
            "uptime_seconds": stats['server_uptime']
        },
        "stream": {
            "frames_captured": stats['frames_captured'],
            "active_clients": stats['active_clients'],
            "total_clients": stats['clients_connected'],
            "current_fps": round(stats['fps'], 1),
            "quality": stats['stream_quality']
        },
        "urls": {
            "local": f"http://localhost:{stream_manager.port}",
            "public": stream_manager.public_url,
            "video_stream": f"{stream_manager.public_url}/video",
            "api_docs": f"{stream_manager.public_url}/"
        },
        "client_integration": {
            "html_example": f"""
            <img src="{stream_manager.public_url}/video" alt="Live Stream">
            """,
            "javascript_example": f"""
            const videoUrl = "{stream_manager.public_url}/video";
            const img = document.createElement('img');
            img.src = videoUrl;
            document.body.appendChild(img);
            """
        }
    }
    return jsonify(info)

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Endpoint not found", "available_endpoints": ["/", "/video", "/snapshot", "/stats", "/health", "/info"]}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

def start_services():
    """Initialize and start all services"""
    logger.info("üöÄ Starting Cloud Webcam Streaming Server...")
    
    # Start camera streaming in background thread
    stream_thread = threading.Thread(target=stream_manager.start_streaming)
    stream_thread.daemon = True
    stream_thread.start()
    
    # Wait for stream to initialize
    time.sleep(3)
    
    # Log startup information
    stats = stream_manager.get_stats()
    logger.info("‚úÖ Server services started successfully!")
    logger.info(f"üìç Local URL: http://localhost:{stream_manager.port}")
    logger.info(f"üåê Public URL: {stream_manager.public_url}")
    logger.info(f"üìä Initial stats: {stats['frames_captured']} frames, {stats['active_clients']} clients")

def signal_handler(signum, frame):
    """Handle shutdown signals gracefully"""
    logger.info("Received shutdown signal...")
    stream_manager.stop()
    sys.exit(0)

if __name__ == '__main__':
    # Register signal handlers for graceful shutdown
    import signal
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Start all services
    start_services()
    
    # Get host and port from environment (for cloud deployment)
    host = os.environ.get('HOST', '0.0.0.0')
    port = int(os.environ.get('PORT', 5000))
    
    logger.info(f"üîß Starting Flask server on {host}:{port}")
    logger.info("üéØ Available endpoints:")
    logger.info("   GET /          - API information")
    logger.info("   GET /video     - MJPEG video stream")
    logger.info("   GET /snapshot  - Single JPEG snapshot")
    logger.info("   GET /stats     - Streaming statistics")
    logger.info("   GET /health    - Health check")
    logger.info("   GET /info      - Server information")
    
    try:
        app.run(
            host=host,
            port=port,
            debug=False,
            threaded=True,
            use_reloader=False
        )
    except KeyboardInterrupt:
        logger.info("\nüëã Received keyboard interrupt...")
    except Exception as e:
        logger.error(f"‚ùå Server error: {e}")
    finally:
        stream_manager.stop()
        logger.info("‚úÖ Server shutdown complete")
